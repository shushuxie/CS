
** 整体的体系结构
unix是一个操作系统,所有的研究是在操作系统之上,使用C语言进行实验;

*** 名词解释

**** unix体系结构
    1. 内核 kernel
       操作系统是软件,提供一个环境,提供程序运行的所需,需要什么呢? 就是硬件资源,所以操作系统是管理硬件资源的一个系统,
       内核是这个软件的最核心部分,负责软件硬件的调度控制;
	#+caption: 内核的理解
	#+begin_quote
	操作系统的内核（Kernel）是计算机操作系统的核心组件，负责管理系统的硬件资源（如CPU、内存、设备等）和提供系统服务。可以从以下几个方面来理解内核：

	1. 资源管理者
	硬件控制：内核直接与硬件交互，负责管理和调度计算机的硬件资源，比如处理器（CPU）、内存、输入/输出设备（如硬盘、网络接口等）。
	进程管理：操作系统中的程序被称为进程，内核负责创建、调度和终止进程，并确保多个进程能够高效地共享CPU时间。
	内存管理：内核管理系统的物理内存和虚拟内存，确保每个进程都有足够的内存空间，防止进程之间的内存互相干扰。
	文件系统管理：内核提供文件系统接口，管理文件的创建、读取、写入和删除等操作，并保证数据的安全性和完整性。
	2. 系统的桥梁
	用户态和内核态：操作系统通常将执行分为“用户态”和“内核态”。用户态是应用程序运行的环境，内核态是内核操作硬件的环境。应用程序不能直接访问硬件，必须通过系统调用与内核进行交互。
	系统调用接口：当程序需要与硬件进行交互或访问操作系统资源时（如文件读写、网络通信），需要通过系统调用（System Call）向内核请求服务。
	3. 安全与隔离
	权限管理：内核负责用户权限的控制，确保只有有足够权限的用户或进程才能执行某些操作。比如，普通用户无法直接操作硬件或修改系统关键文件。
	进程隔离：内核通过内存管理机制，确保不同进程互不干扰，提高系统稳定性和安全性。如果某个进程崩溃，它不会影响其他进程或整个系统。
	4. 核心类型
	单内核（Monolithic Kernel）：如Linux内核，它将所有功能（如设备驱动、文件系统、网络协议等）都放在同一个内核空间中运行。优点是性能较好，缺点是任何一个组件的错误可能导致整个系统崩溃。
	微内核（Microkernel）：如Minix内核，它将很多功能（如驱动程序、文件系统等）移到用户空间运行，内核只保留基本功能，如进程管理、内存管理等。这样设计的优点是更稳定和灵活，但性能可能有所下降。
	5. 常见的内核示例
	Linux 内核：广泛应用于服务器、桌面和移动设备，开源且具有高度可定制性。
	Windows NT 内核：用于所有现代的Windows操作系统，具有较强的兼容性和安全性。
	MacOS 和 iOS 使用的 XNU 内核：结合了微内核和单内核的设计优点，提供稳定性和性能。
	总结来说，操作系统的内核是一个复杂的管理与协调层，保证硬件资源的有效利用，管理进程与内存，提供系统调用接口，并确保系统安全与稳定。
	#+end_quote

    2. 内核和硬件的交互
       #+begin_quote
       1. 设备驱动程序（Device Drivers）
概念：设备驱动程序是内核与硬件之间的中间层，是一段特定的软件代码，用来管理某种类型的硬件设备（如网卡、显卡、硬盘等）。每种硬件设备都需要相应的驱动程序，内核通过驱动程序与硬件通信。
作用：驱动程序向内核提供了一种统一的接口，内核通过这些接口与不同的硬件设备进行交互。这样，应用程序不需要直接处理硬件细节，而是通过系统调用与内核沟通，内核再通过驱动程序将请求转发给硬件。
示例：

当用户要求读取硬盘上的数据时，内核会通过硬盘的驱动程序发送读请求，驱动程序将请求转换成硬盘能理解的命令，硬盘执行操作后返回数据，驱动程序再将数据传递给内核。
2. 中断（Interrupts）
概念：中断是硬件用来通知内核发生事件的一种机制。硬件设备（如键盘、网卡）完成某项任务或需要内核处理某个事件时，会向CPU发出中断信号。中断可以打断CPU当前正在执行的任务，转而处理紧急的硬件事件。
作用：中断使内核能够快速响应硬件事件。例如，当键盘按下某个键时，键盘控制器会发出中断信号，内核暂停当前的任务，处理键盘输入，然后恢复原来的工作。这样可以避免内核频繁轮询设备，提升效率。
中断类型：

硬件中断：由硬件设备（如硬盘、网络设备）发出。例如，硬盘完成数据读取后，会通过硬件中断通知内核。
软件中断：由软件程序发出，用于请求内核服务或处理某些事件。
中断处理流程：

硬件设备向CPU发出中断信号。
CPU暂停当前任务，跳转到内核的中断处理程序（Interrupt Handler）。
内核根据中断类型进行处理，处理完成后恢复之前的任务。
3. 输入输出端口（I/O Ports）和内存映射I/O（Memory-Mapped I/O）
I/O端口通信：某些硬件设备通过输入输出端口（I/O Ports）与内核通信。这些端口是特殊的硬件地址，内核可以向这些地址发送指令或读取数据。
过程：内核通过特定的指令访问设备的I/O端口，进行读写操作。比如，内核可以通过写入命令到网卡的I/O端口来控制网络数据的发送和接收。
内存映射I/O：另一种硬件通信方式是将设备的寄存器映射到系统的物理内存空间。通过这种方式，内核可以像访问内存一样，直接访问硬件设备的寄存器。
过程：内核将硬件设备的寄存器或内存映射到系统的虚拟内存空间，然后通过内存读写操作控制硬件。例如，显卡的帧缓冲区通常是通过内存映射方式供内核和应用程序直接访问的。
4. 系统总线（System Bus）
概念：系统总线是连接CPU、内存和外部设备的通信通道，用于在硬件之间传输数据。常见的总线有PCI（用于扩展卡，如显卡、网卡）、USB（用于外部设备，如键盘、鼠标）、SATA（用于硬盘）等。
作用：内核通过总线控制器与硬件设备进行通信。每个硬件设备通过总线连接到CPU，内核通过总线控制器向设备发送指令并接收设备的响应。
5. 直接内存访问（DMA, Direct Memory Access）
概念：DMA 是一种允许硬件设备直接访问系统内存，而不需要CPU介入的技术。通过DMA，硬件设备可以自主完成数据传输，提高了系统效率。
作用：内核配置DMA控制器，将数据传输任务交给硬件设备。硬件设备在完成传输后，通过中断通知内核。这减少了CPU的负担，使其可以专注于其他任务。
示例：当网卡从网络中接收到数据时，它可以通过DMA直接将数据写入内存，而不需要通过CPU逐字节处理。完成后，它会通过中断通知内核数据已准备好。

6. 时钟（Clock）和定时器（Timers）
概念：内核使用系统时钟和定时器来跟踪时间、调度任务和管理资源。系统时钟会周期性产生中断信号，内核根据这些时钟中断来更新系统时间并执行任务调度。
作用：定时器可以用来处理硬件的定时任务，例如定期检查设备状态或触发某些周期性操作。
总结
内核与硬件的交互通过设备驱动程序、中断机制、I/O 端口、内存映射、系统总线、DMA、时钟与定时器等多种机制实现。这些机制使得内核能够高效地管理硬件资源，并为应用程序提供统一的硬件访问接口，确保操作系统的稳定性和性能。
       #+end_quote

    3. 用户态和内核态
	属性	用户态	                        内核态
	权限	受限，不能直接访问硬件资源      	完全权限，可以访问所有硬件和系统资源
	运行的代码	用户程序（应用程序）	        操作系统内核代码、驱动程序
	指令执行	只能执行非特权指令	                可以执行所有指令，包括特权指令
	资源访问	通过系统调用间接访问硬件资源    	直接访问硬件资源
	稳定性	稳定，用户程序的错误不会影响整个系统	内核态出错可能导致系统崩溃
	切换	通过系统调用、中断或异常切换到内核态	通过返回系统调用或中断服务例程切换到用户态

    #+caption: 内核态和用户态的切换
    #+begin_example
1. 系统调用切换过程
系统调用是用户态程序向操作系统请求服务的主要方式，例如文件读写、内存分配等操作。系统调用会触发从用户态到内核态的切换。以下是这个过程的详细步骤：

(1) 用户态程序发出系统调用请求
用户态程序通过调用库函数发出系统调用请求。例如，read() 是一个典型的系统调用，用户程序请求从文件中读取数据。
在实际执行时，用户态程序调用的库函数会使用一条特殊的陷入指令（Trap Instruction），将控制权交给操作系统内核。
(2) 陷入指令（Trap Instruction）触发硬件中断
系统调用会触发一个软件中断（通常叫做“陷入”），这是一种特定的CPU指令，用来切换到内核态。
在x86架构中，常用的陷入指令是 int 0x80 或 syscall 指令。
当CPU执行这条指令时，会自动保存当前的用户态上下文，包括寄存器、程序计数器（PC，指向当前指令的地址）等，以便稍后能够返回用户态继续执行。
(3) CPU切换到内核态
当陷入指令执行后，CPU将切换到内核态。具体的切换过程由硬件（CPU）和操作系统共同完成。
CPU会从用户态的低权限模式切换到内核态的高权限模式，允许执行特权指令，并且能够访问内核空间的资源。
同时，CPU会跳转到操作系统为系统调用设置的中断处理程序入口，通常是一个预定义的地址，即系统调用的入口函数。
(4) 内核态开始执行系统调用处理程序
在内核态，操作系统根据陷入时提供的系统调用号（System Call Number），确定用户态程序请求的具体服务。例如，调用 read() 时，系统调用号可能对应文件系统的读操作。
内核会根据系统调用号查找相应的系统调用处理程序（如文件读写、进程管理、内存分配等），并开始执行这些内核态的函数。
内核处理过程中，可能会访问硬件资源（如读取磁盘数据）或执行其他特权操作。
(5) 处理完成，返回结果给用户态
系统调用处理程序执行完后，内核会将结果（如读取的数据、成功或错误状态）存储在某些寄存器或内存位置中，准备返回给用户态程序。
内核还会恢复用户态的执行环境，包括原来的寄存器状态和程序计数器位置。
(6) 从内核态返回用户态
内核通过另一条指令将CPU从内核态切换回用户态。在x86架构中，这通常是 iret 指令，它会恢复用户态的程序计数器、堆栈指针等上下文，切换回用户态执行。
通过 iret 指令，CPU重新进入低权限的用户态，继续执行从系统调用返回后的代码。
(7) 用户态程序继续执行
返回用户态后，用户程序通过检查系统调用的返回值来确定操作结果。例如，如果 read() 系统调用成功，程序会获取读取到的数据；如果失败，则会获取错误码。
用户程序继续执行后续的代码。
2. 中断切换过程
除了系统调用，硬件中断也是用户态和内核态之间切换的重要机制。中断通常由外部硬件设备（如键盘、网络、硬盘）触发，通知操作系统有事件需要处理。中断引发的切换过程与系统调用类似，具体步骤如下：

(1) 硬件设备发出中断信号
当硬件设备完成某个任务或发生特定事件时，它会向CPU发出中断信号。例如，硬盘完成数据读取后会发出中断，通知操作系统数据已经准备好。
这个中断信号打断当前运行的用户态程序，CPU响应中断信号。
(2) CPU保存当前用户态上下文
和系统调用类似，CPU会保存当前的用户态上下文（寄存器状态、程序计数器等），以便稍后恢复。
CPU自动跳转到内核中与中断类型对应的中断处理程序。
(3) CPU切换到内核态
响应中断后，CPU切换到内核态，进入高权限模式，允许操作系统访问硬件和执行特权指令。
内核开始执行相应的中断处理程序，例如处理硬盘读取、网络数据接收等操作。
(4) 内核处理中断
内核态的中断处理程序处理来自硬件的请求，并完成相应的操作。处理完成后，内核可能会将数据交给相关的用户态程序，或更新系统状态。
(5) 内核返回用户态
中断处理完成后，内核恢复用户态的上下文，使用 iret 或类似指令切换回用户态。
用户程序继续执行，被中断前的代码。
3. 异常处理切换过程
当程序在用户态遇到错误（如除零、非法内存访问等）时，会触发异常。异常处理的切换过程与系统调用和中断类似。以下是其主要步骤：

(1) 用户态程序发生异常
例如，用户态程序试图访问非法内存地址或执行非法指令时，CPU会检测到这些错误。
(2) CPU触发异常，切换到内核态
异常触发后，CPU会像处理中断一样，保存当前的用户态上下文，并切换到内核态，执行异常处理程序。
(3) 内核处理异常
内核根据异常类型进行处理，可能是终止用户进程、生成错误信号等。严重异常可能导致程序崩溃。
(4) 内核处理完成，返回或终止
如果异常可以处理，内核会将控制权返回用户态，否则会终止当前进程。
总结
用户态和内核态的切换通过系统调用、中断和异常等机制实现。具体过程如下：

用户态程序发出系统调用或硬件触发中断/异常。
CPU保存用户态上下文，并切换到内核态。
内核处理系统调用、中断或异常。
处理完成后，内核恢复用户态上下文并返回，用户程序继续执行。
这种切换机制确保了操作系统对硬件资源的安全管理和用户程序的正常执行，同时也隔离了用户程序的错误对整个系统的影响。
    #+end_example
	
    3. 系统调用 System call
       内核的调用也是通过一些接口,这些接口的调用称为系统调用.
    4. Shell
       shell的含义就是壳,也就是包裹在内核之上的外壳,可以看作一个特殊的程序,一般可以直接通过系统调用,比较高效;
    5. 公共函数库
       #+caption: 公共函数库和系统调用的区别
	#+begin_example
    1. 公共函数库（Standard Library）
    (1) 定义
    公共函数库（也叫标准库或共享库）是操作系统或编程语言提供的一组预编译的函数，应用程序可以通过这些库函数来执行常见的任务，如字符串操作、数学计算、文件I/O操作等。常见的库包括 C 标准库（libc）、数学库（libm）等。

    (2) 作用
    公共函数库简化了应用程序的开发，提供了许多常见的功能，以避免程序员重复实现常用的功能。例如：

    C 标准库中的 printf() 函数：用于输出文本到控制台。
    fopen() 函数：用于打开文件。
    这些库函数通常是高层次的，并封装了底层的系统调用，程序员可以使用这些库函数来完成复杂的任务，而无需直接处理底层系统的细节。

    (3) 执行方式
    公共函数库在用户态执行，意味着这些库函数并不直接与操作系统内核或硬件交互。当需要访问硬件资源（如文件、内存、设备）时，库函数可能会内部调用系统调用来完成这些操作。

    示例：

    当你在 C 程序中调用 printf() 输出内容时，printf() 是公共函数库中的函数，它会进一步调用系统调用（如 write()）来将数据输出到屏幕。
    (4) 特点
    运行在用户态：公共函数库运行在用户态中，因此它们没有直接访问硬件的权限。
    封装系统调用：某些库函数会封装系统调用。比如，fopen() 库函数最终会调用系统调用来打开文件。
    便于程序开发：通过使用公共函数库，开发者可以专注于应用逻辑，而无需处理底层的系统细节。
    2. 系统调用（System Call）
    (1) 定义
    系统调用是操作系统提供的接口，用于让用户态的程序访问系统资源（如文件系统、内存、硬件设备等）。系统调用是程序与操作系统内核之间的桥梁，它允许用户态程序请求操作系统内核执行特权操作。

    (2) 作用
    系统调用的作用是提供对操作系统内核服务的访问。常见的系统调用包括：

    文件操作：open()、read()、write()、close()，用于文件的读写操作。
    进程管理：fork()、exec()，用于创建和管理进程。
    内存管理：mmap()、brk()，用于管理进程的内存空间。
    设备控制：ioctl()，用于与硬件设备交互。
    (3) 执行方式
    系统调用通过一个用户态到内核态的切换过程来执行。当用户态程序发出系统调用时，CPU会切换到内核态（这是一个高权限的模式），然后操作系统内核执行相应的操作。完成后，控制权返回用户态，程序继续执行。

    示例：

    当你调用 write() 系统调用时，操作系统内核会在内核态执行实际的写入操作，比如将数据写入文件或输出到屏幕。
    (4) 特点
    运行在内核态：系统调用进入内核态运行，具有访问硬件资源的最高权限。
    直接与内核交互：系统调用直接由操作系统内核处理，用于访问受保护的资源和执行特权操作。
    开销较高：由于系统调用涉及从用户态到内核态的切换，这个过程会有一些性能开销。
    3. 公共函数库与系统调用的区别
    属性	公共函数库（Standard Library）	系统调用（System Call）
    执行模式	运行在用户态	运行在内核态
    功能	提供常见的功能，如字符串操作、文件I/O，常常封装系统调用	提供访问系统资源和硬件的接口，如文件操作、进程管理等
    与内核的关系	通常不直接与操作系统内核交互，除非调用系统调用	直接与操作系统内核交互，提供对内核服务的访问
    权限	运行在用户态，权限受限	运行在内核态，具有高权限，能够访问受保护的资源
    性能	执行较快，因为没有用户态和内核态的切换	开销较高，因为涉及用户态和内核态的切换
    示例	printf()、strlen()、fopen()	read()、write()、fork()、exec()
    作用	提供常见任务的高层封装，简化编程	允许用户程序请求内核进行硬件操作和受保护资源访问
    4. 二者的联系
    公共函数库封装系统调用：许多公共函数库（例如 fopen()、printf()）内部会调用系统调用来完成实际的硬件操作。库函数提供了一层抽象，使得程序员不必直接处理系统调用。
    系统调用作为底层接口：公共函数库中的某些函数在执行过程中最终会调用系统调用来与操作系统内核交互。例如，printf() 库函数最终会调用 write() 系统调用将数据输出到标准输出设备。
	#+end_example


#+DOWNLOADED: screenshot @ 2024-09-22 00:31:37
[[file:images/2024-09-22_00-31-37_screenshot.png]]










**** 登录
1. 登陆名和密码
2. shell
   用户登陆后就会有一个默认的shell,可以与操作系统交互

**** 文件和目录
根目录/
每创建一个目录都会有 ~.~ 和 =..= 两个目录,分别代表当前目录和上层目录
根目录是特殊的目录上层目录也是自己


