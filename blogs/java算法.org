
   刷了一些简单的题目，有的题目觉得很简单但就是没法好好的完成，总是碰到某个部分弄不好；
   也知道了一个技巧，就是先确定好步骤然后再开始写，不然最后没法好好的完成；还有就是多
   使用一些现有的工具。例如排序，建立对象等等
* 算法语法问题
** 二分查找算法
    主要是在一个数组中找寻某个值，对于某个排序数组真的很好用，效率很高
    注意点：
    1. 确定区间，[] or [ )
    2. 根据区间确定middle的走向
       #+begin_src java
	 public int findTarget (int target,int[] nums) {
        // 左闭右闭的写法
        int left = 0;
        int right = nums.length - 1; // 这里为了对应真实的index -1
        while (left <= right) { // 两边都是闭区间，left可以等于right
            int mid = left + ((right - left) >> 2);
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                // 收缩右区间
                right = mid - 1;// 因为mid已经计算过
            } else {
                // 收缩做区间
                left = mid + 1; // mid已经计算过了
            }
        }
        return -1;
    }

    public int findTarget2 (int target,int[] nums) {
        // left[ right)
        int left = 0;
        int right = nums.length;
        while (left < right) {// 因为是开区间，实际上达不到right的位置
            int mid = left + ((right - left) >> 2);
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                // 收缩右区间
                right = mid;// 这里要等于，开区间实际上掠过了mid了
            } else {
                left = mid + 1; // 左闭，这里已经计算过应该略过
            }
        }
        return -1;
    } 
    #+end_src

虚拟机分配
 int[] dispatchRequests(int[] capacities, int[] requests) {
        int[] result = new int[requests.length];
        Comparator<int[]> comparator = (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];

        // TreeMap 按容量降序排列
        TreeMap<Integer, PriorityQueue<int[]>> map = new TreeMap<>(Comparator.reverseOrder());

        // 初始化：将所有服务器按容量分组
        for (int i = 0; i < capacities.length; i++) {
            map.computeIfAbsent(capacities[i], k -> new PriorityQueue<>(comparator))
                    .offer(new int[]{0, i}); // [部署数量, 服务器索引]
        }

        for (int i = 0; i < requests.length; i++) {
            Map.Entry<Integer, PriorityQueue<int[]>> entry = map.firstEntry();
            if (entry == null || entry.getKey() < requests[i]) {
                result[i] = -1;
                continue;
            }

            int cap = entry.getKey();
            PriorityQueue<int[]> queue = entry.getValue();
            if (queue.isEmpty()) {
                result[i] = -1;
                map.remove(cap);
                continue;
            }

            int[] server = queue.poll();
            server[0]++; // 增加部署数量
            result[i] = server[1]; // 记录服务器索引

            int newCap = cap - requests[i];
            map.computeIfAbsent(newCap, k -> new PriorityQueue<>(comparator))
                    .offer(server);

            // 如果原容量队列为空，移除
            if (queue.isEmpty()) {
                map.remove(cap);
            }
        }

        return result;
    }

 int[] dispatchRequest(int[] capacities, int[] requests) {
        // [cap, queue<id>] 容量 - 相同容量的id集合
        TreeMap<Integer, PriorityQueue<Integer>> mp = new TreeMap<>();
        for (int i = 0; i < capacities.length; i++) {
            mp.computeIfAbsent(capacities[i], k -> new PriorityQueue<>()).offer(i);
        }

        int[] ans = new int[requests.length];
        Arrays.fill(ans, -1);

        for (int i = 0; i < requests.length; i++) {
            // 返回大于并且最接近request[i]的值 >=
            Map.Entry<Integer, PriorityQueue<Integer>> entry = mp.ceilingEntry(requests[i]);
            if (entry == null) {  // 没有足够空间
                continue;
            }

            int cap = entry.getKey();
            PriorityQueue<Integer> q = entry.getValue();
            ans[i] = q.poll();

            if (q.isEmpty()) {
                mp.remove(cap); // 没有对应容量的机器，删除key
            }

            // 更新新的容量对象
            int nextCap = cap - requests[i];
            mp.computeIfAbsent(nextCap, k -> new PriorityQueue<>()).offer(ans[i]);
        }

        return ans;
    }

：
