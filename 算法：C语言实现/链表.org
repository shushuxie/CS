
**** 链表--list

***** 定义
    链表是一组数据项的集合，其中每个数据项都是节点的一部分，每个节点都包含指向下一节点的链接
    其中包含：数据项，节点，链接三部分；

***** 链表末尾节点的规定
****** 将其置为不指向任何节点的空链接;
****** 使其指向不包含任何元素的哑元节点;
****** 使其指向第一个节点（首节点），使链表成为循环链表；

* TODO 对比插入链表删除操作的不同

* TODO todo2

***** 两种声明方式

****** 指针作为link
    #+begin_src c++
    //基本结构的实现；包含链接和节点两个部分
    //链接是指向节点的指针，节点中包含链接；
    //该方式不能写为一个声明，node必须声明出来才能声明后续指针
    typedef struct node *link;
    struct node{
	int item;
	link next;
    };
    二者等价
    typedef struct node {
	int item;
	// 此处是struct node类型，没有使用lin；
	struct node *next;
	
    } *link2;
    
    #+end_src>
    
****** 约瑟夫环实现

    #+begin_src c++
    #include <stdlib.h>
    #include "stdio.h"

    typedef struct node {
        int item;
	    // 此处是struct node类型，没有使用lin；
	        struct node *next;
		
    } *link;

    int main(){
        // 初始化第一个节点
	// 这里x作为临时变量十分重要，指代最新的节点
    link t= malloc(sizeof (*t)), x=t;
    t->item = 1;
    t->next = t; // 指向自身
    int i, N =5, M=3;
    for (i = 2; i<=N; i++) {
    // 两个作用，1.新的节点由上一个节点指代，形成链接
    // 2. 返回值赋值给中间变量x，用来操作新的节点
    x = (x->next = malloc(sizeof *x));
    x->item = i;
    x->next = t; // 新的节点指向首节点，形成圆环
	}
	 // 开始判断时：x指向最后一个节点
	while (x != x->next)
	  {
	  for (i = 1; i<M; i++)
	x = x->next; // 跳过M-1个节点
        x->next = x->next->next; // 删除下一个节点
        N--;
    }
    printf("%d \n",x->item);
    
    return 0;

    }
}

    #+end_src>

    

****** 链表练习题-part1

******* 1. 获取循环链表节点数的函数(3.24)
	#+begin_src c++
	int getLinkCount(link plink){
	int i = 1;
	link tmp = plink;// 临时变量存储初始值，然后循环对比
	while (plink != tmp->next)
	{
	 i++;
	 tmp = tmp->next;// 移动一位
	   
	}
	    return i;
	    })
	}
	#+end_src>
	
******* 2. 获取循环链表之间的节点数(3.25)
	#+begin_src c++
	int getTwoLinkLength(link x, link t) {
	    // 返回的是 x-t之间的距离，还有t到x之间的距离没有计算
	int m = 0;
	while (x->next != t)
	{
	    m++;
	    x = x->next;

	}
	    return m;
	    })
	}
	#+end_src>

******* 3. 两个链表插入合并（3.26）
#+begin_src c++
void mergeTwoLink(link x,link t) {
    // 两个链表分开有四个点，然后按顺序连接
    // 从x节点处断开
    link xNext = x->next;
    x->next = t;
    // t的上一个节点和x的下一个相连 temp节点
    link tPre = t;
    while (1)
    {
        if (tPre->next == t)
            break;
        tPre = tPre->next;
    }
    tPre->next = xNext;

    link tmp = x;// 临时变量为了锚定固定点，停止遍历
    while (1)
    {
        if (x->next == tmp)
            break;
        printf("num = %d \n",x->item);
        x = x->next;
    }
    printf("num = %d\n",x->item);
}
#+end_src>



*****  链表常用的操作
****** 1. 循环链表（没有空指针）
	#+caption: 循环链表常用操作
	#+begin_src c++
	  // 循环链表常用操作
	  // 1.头插入
	  head->next = head;

	  // 2. x节点后插入t节点
	  t->next = x->next;
	  x->next = t;

	  // 3. 删除x后的节点
	  x->next = x->next->next

	  // 4. 遍历循环
	  t=head;
	  do{...t=t->next;
	    }while(t!=head);

	  // 5. 是否只有一个元素
	  if(head->next == head)
	#+end_src

	#+caption: 
	#+begin_src c++

	#+end_src
****** 2. 头指针，尾节点为空
	#+begin_src c++
	// 初始化
	head = NULL;
	// 在x节点后插入t节点
	if (x == Null)
	{
	    head = t;
	    head->next = NULL;
	}
	else
	{
	    t->next = x->next;
	    x->next = t;
	}
	// 删除x后的节点
	t = x -> next;
	x -> next = t -> next;
	// 遍历循环
	for (t = head; t != NULL; t = t->next)
	// 测试是否为空
	if （head == NULL）
	#+end_src>


****** 3. 有哑远节点，尾节点为空
	#+begin_src c++
	// 初始化
	head = malloc(sizeof *head);
	head->next = NULL;

	// 在x节点后插入t节点
	t -> next = x -> next;
	x -> next = t;

	// 删除x后的节点
	t = x -> next;
	x -> next = t -> next;

	// 遍历循环
	for (t = head -> next; t != NULL; t = t -> next)

	// 测试是否为空
	if (head -> next == NULL)

	#+end_src>
****** 4. 有哑远节点，尾节点
	#+begin_src c
	//初始化
	head = malloc (sizeof *head);
	z = malloc (sizeof *z);
	head->next = z;
	z->next = z;
	// 在x节点后插入t节点
	t -> next = x;
	x -> next = t;
	// 删除x后的节点
	x -> next = x->next->next;
	// 遍历循环
	for (t = head->next; t != z; t = t->next)
	// 测试是否为空
	if (head -> next == z)
	#+end_src>





***** 链表接口
#+begin_src c
typedef struct node *link;
struct node {ItemType item;link next;};
typedef link Node;
void initNode(int); //初始化链表
link newNode(int);
void freeNode(link);
void insertNext(link,link);
link deleteNode(link);
link Next(link);
int Item(link);
#+end_src>



***** 双向链表

[[file:imags/Snipaste_2023-10-27_11-09-27.png][双向链表操作]]





****** 链表练习-part2


******* 1.把链表中最大数据移动到最后一位(3.34)
#+begin_src c
#include<stdlib.h>
#include <printf.h>

typedef struct node *link;
struct node{
int item;
link next;

};
void mvMaxItemToEnd(link x) {
// 确定最大数据的节点
link t,u,end;
t = x;
int num = x->item;
while (t != NULL)
 {
 if (t->item > num)
 {
num = t->item;

}
t = t->next;
}
 // 确定节点,前一个节点
link pre;
t = x;
while (t != NULL)
{
 if (t->item == num)
 {
u = t;
break;

}
t = t->next;
}
// 确定前一个节点
if (u != x) // 不是首节点
{
if (t->next->item == num)
pre = t;

}
// 确定尾节点
   t = x;
while( t != NULL)
   {
  if (t->next == NULL)
   {
end = t;
 break;
 }
    t = t->next;
	}
    // 移动
if (pre->next != NULL)
   {
   pre->next = u->next;
   end->next = u;
   u->next = NULL;

} else {
 x = x->next;
 end->next = u;
 u->next = NULL;

}
printf("num = %d\n",num);
}

int main() {
    link x = malloc(sizeof *x),t;
x->item = 66;
    x->next = NULL;
t = x;
   for (int i = 0; i < 4; i++)

t = (t->next = malloc(sizeof *t));
t->item = rand() % 20 * 3;

}
    t->next = NULL;
mvMaxItemToEnd(x);
   return 0;


}


#+end_src>

******* 2.最小数字移到头部节点(3.35)
#+begin_src c
void mvMinToFirst(link x) {
    // 找到最小数字
link t = x->next;
int tmp = t->item;
for ( ; t != NULL; t = t->next) {
if (tmp > t->item)
tmp = t->item;
				      
}
    // 找到当前节点
link curr;
for (t = x->next; t != NULL; t = t->next) {
if (t->item == tmp)
curr = t;
}
// 找到前一个节点
link pre;
for (t = x; t != NULL; t = t->next) {
if (t->next->item == tmp ) {
pre = t;
break;
									        
}
    }
// 移动
if (pre != x) {
pre->next = curr->next;
curr->next = x->next;
 x->next = curr;
				        
}
}

int main() {
 // 带有哑元节点的链表
 struct node head;
 link x = &head, t;
 t = x;
 for (int i = 0; i < 5; i++)
{
t = (t->next = malloc(sizeof *t));
t->item = rand() % 15 * 3;
		    
}
    t->next = NULL;
    mvMinToFirst(x);
    return 0;
}

#+end_src>

******* 偶数位置节点排在奇数节点之后，相对位置不变(3.36)
int main() {
    // 带有哑元节点的链表
        struct node head;
	    link x = &head, t;
	        t = x;
		    for (int i = 0; i < 5; i++)
		        {
			        t = (t->next = malloc(sizeof *t));
				        t->item = rand() % 15 * 3;
					    
}
    t->next = NULL;
        mvMinToFirst(x);
	    return 0;

	    
}

#+begin_src c
#include<stdlib.h>
#include <printf.h>

typedef struct node *link;
struct node{
    int item;
        link next;
	
};
void mvMaxItemToEnd(link x) {
    // 确定最大数据的节点
        link t,u,end;
	    t = x;
	        int num = x->item;
		    while (t != NULL)
		        {
			        if (t->item > num)
				        {
					            num = t->item;
						            
}
        t = t->next;
	    }
	        // 确定节点,前一个节点
		    link pre;
		        t = x;
			    while (t != NULL)
			        {
				        if (t->item == num)
					        {
						            u = t;
							                break;
									        
}
        t = t->next;
	    }
	        // 确定前一个节点
		    if (u != x) // 不是首节点
		        {
			        if (t->next->item == num)
				            pre = t;
					        
}
    // 确定尾节点
        t = x;
	    while( t != NULL)
	        {
		        if (t->next == NULL)
			        {
				            end = t;
					                break;
							        
}
        t = t->next;
	    }
	        // 移动
		    if (pre->next != NULL)
		        {
			        pre->next = u->next;
				        end->next = u;
					        u->next = NULL;
						    
} else {
        x = x->next;
	        end->next = u;
		        u->next = NULL;
			    
}
    printf("num = %d\n",num);
    }

    void mvMinToFirst(link x) {
        // 找到最小数字
	    link t = x->next;
	        int tmp = t->item;
		    for ( ; t != NULL; t = t->next) {
		           if (tmp > t->item)
			              tmp = t->item;
				          
    }
        // 找到当前节点
	    link curr;
	        for (t = x->next; t != NULL; t = t->next) {
		        if (t->item == tmp)
			            curr = t;
				        }
					    // 找到前一个节点
					        link pre;
						    for (t = x; t != NULL; t = t->next) {
						          if (t->next->item == tmp ) {
							            pre = t;
								              break;
									            
    }
        }
	    // 移动
	        if (pre != x) {
		        pre->next = curr->next;
			        curr->next = x->next;
				        x->next = curr;
					    
    }
    }
    void sortNumtoRelationLocation(link x) {
        // 找到最后一个奇数位置
	    link t,u,p;
	        int cNum,eNum; //遍历到的奇数位置，最后一位奇数位置
		    for (t = x->next; t != NULL; t = t->next) {
		            if (t->item %2 != 0) {
			                u = t;
					            eNum = u->item;
						                printf("odd num = %d\n",u->item);
								        
    }
        }
	    // 遍历移动 p前一个位置，t遍历位置，u插入标记位置
	        while (cNum != eNum) {
		        for (p = x,t = x->next; t != NULL;p=p->next,t = t->next) {
			            if (t->item %2 == 0) {
				                    p->next = t->next;
						                    t->next = u->next;
								                    u->next = t;

										                    u = u->next; //当前位置后移一位，方便后续插入
												                    break;
														                
    } else {
                    cNum = t->item;
		                
    }
                if (cNum == eNum)
		                break;
				        
    }
        }
	    printf("cNum = %d, eNum = %d\n",cNum,eNum);
	    }
	    int main() {
	        // 带有哑元节点的链表
		    struct node head;

		        link x = &head, t;
			    x->next = malloc(sizeof *x);
			        x->next->item = 0;
				    t = x;
				        for (int i = 0; i <= 6; i++)
					    {
					            t = (t->next = malloc(sizeof *t));
						            t->item = i;
							        }
								    t->next = NULL;
								        sortNumtoRelationLocation(x);
									    return 0;

									    
			}
			>)
    }

#+end_src>


