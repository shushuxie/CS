
** C提供数据结构

**** 字符串--string

***** 基本

	#+begin_src 
	1. 字符串使用""包围，字符使用''包围
	2. 字符串结尾是'\0',因此占用，申请空间要比字符多一个字节；
	3. 声明方式：
		字符数组：char s1[4] = {'1','2','3','\0'};
			char s2[] = "123";
			char s3[4] = "123";
		指针方式：char *str = "123";
	4. \0包含情况
		"123",以字符串声明的编译器会自动添加'\0'
		{'1','2'},以字符数组声明的如果没有添加则不包含
	5. 修改字符串
		以指针声明的其实是const char *str,只是一个引用。不可修改
		数组方式是在栈内存中的，可以修改；
	6. sizeof 和 strlen
		sizeof获取的是占用内存大小，包含'\0',如果是指针，获取的就是指针占用空间，而不是指针指代的字符串
		strlen获取字符串本身长度，不包含'\0'char s1[3] = {'1','2'},{'1','2','\0'} 和 char s[]="12",char *pstr = "12"结果一样；
		计算字符数组长度时如果没有自带'\0',则字符数组长度需显式声明出来且大于字符数；因为strlen源码是循环判断字符直到为假,
		结尾'\0'和多余空间0会被判定为假

	#+end_src

***** 常用函数
	#+begin_src 
	*include <string.h>
	1. int  strlen -- 求字符串长度；不包含‘\0’，字符数组必须包含，或者申请多余的空间才行；
	2. char * strcat(char *s1,const char *s2) -- 拼接字符串；s1必须有足够的空间才能拼接，数组必须给出多余拼接空间，指针必须申请相应的空间才行；
	3. int strcmp -- 比较字符串是否相同； 0 表示相同，正数或负数表示不同；if(strcmp(s1,s2) == 0);
	4. char * strcpy(str *des,const char *s) -- 复制字符串，注意目标需要有足够的空间才行；
	5. 字符串转数字 <stdlib.h> ;转int，float，double，atoi(),atof(),atod(),还有strtoi()等；
	6. 批量初始化内存； memset(char *des,内容,空间大小）； 需要注意初始化之前必须有对应空间；
	#+end_src>

**** 数组--array

**** 自定义类型--tydef
	就是为一些声明起一个别名；特别是一些复杂的声明，可以更好的引用，也可以换用一个易于理解的名字；
	typedef unsigned int bool;
	typedef char *str ok;
	```
	typedef struct tagPoint  
	{   double x;
	    double y;
	    double z;
	} Point;
	```

**** 结构体--structure
	结构体分三个部分：定义，声明，初始化；
	可以分单步也可以一下子完成；
	声明的时候必须带上struct关键字；

	```
	 // 定义一个名为point的结构体
	    struct point {
		int x;
		int y;
		int z;
	    };
	    // 声明一些成员
	    struct point p1,p2,p3={1,2,1};
	    // 初始化一些值
	    p1.x = 1;
	    p2.z = 3;
	    
	   // 一个操作完成所有
	   struct stu{
	       int tall;
	       int weight;
	   }s1={1,2},s2;

	   // 结构体定义为新的类型
	   typedef struct bird{
	       int weight;
	       int color;
	   } bird_t; 
	   bird_t  b1 = {1,3};
	   
	   使用typedef可以省略结构体命名，直接把一个结构体声明为一个特定的类型
	   typedef struct{
	       int weight;
	       int color;
	   } bird_t; 
	   bird_t  b1 = {1,3};

	  // 也可以省略类型，声明一些变量
		struct{
		    int a;
		    int b;
		} a,b,c;
	```

**** 联合--union
 **联合，也叫共用体，所有成员共用一段内存，内存中只报错最新的数据**
	```
	    union{
		int a;
		char b;
	    }u1,u2;
	    u1.a=97;
	    printf("%d,%c\n",u1.a,u1.b); //97,a 说明共用一段内存，只是解析不同；
	    u1.b = 98;
	    printf("%d,%c\n",u1.a,u1.b); //98,b 说明使用最新的内存，进行了覆盖；
	```
**** 枚举--enum
相当于为一些量赋初始值，
enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };
enum week a,b;
a = Mon,b=Sun;

**** 抽象结构类型
**** 链表--list

***** 定义
    链表是一组数据项的集合，其中每个数据项都是节点的一部分，每个节点都包含指向下一节点的链接
    其中包含：数据项，节点，链接三部分；

***** 链表末尾节点的规定
****** 将其置为不指向任何节点的空链接;
****** 使其指向不包含任何元素的哑元节点;
****** 使其指向第一个节点（首节点），使链表成为循环链表；

***** 两种声明方式

****** 指针作为link
    #+begin_src c++
    //基本结构的实现；包含链接和节点两个部分
    //链接是指向节点的指针，节点中包含链接；
    //该方式不能写为一个声明，node必须声明出来才能声明后续指针
    typedef struct node *link;
    struct node{
	int item;
	link next;
    };
    二者等价
    typedef struct node {
	int item;
	// 此处是struct node类型，没有使用lin；
	struct node *next;

    } *link2;

    #+end_src>
    
****** 约瑟夫环实现

    #+begin_src c++
    #include <stdlib.h>
    #include "stdio.h"

    typedef struct node {
        int item;
	    // 此处是struct node类型，没有使用lin；
	        struct node *next;
		
    } *link;

    int main(){
        // 初始化第一个节点
	// 这里x作为临时变量十分重要，指代最新的节点
    link t= malloc(sizeof (*t)), x=t;
    t->item = 1;
    t->next = t; // 指向自身
    int i, N =5, M=3;
    for (i = 2; i<=N; i++) {
    // 两个作用，1.新的节点由上一个节点指代，形成链接
    // 2. 返回值赋值给中间变量x，用来操作新的节点
    x = (x->next = malloc(sizeof *x));
    x->item = i;
    x->next = t; // 新的节点指向首节点，形成圆环
	}
	 // 开始判断时：x指向最后一个节点
	while (x != x->next)
	  {
	  for (i = 1; i<M; i++)
	x = x->next; // 跳过M-1个节点
        x->next = x->next->next; // 删除下一个节点
        N--;
    }
    printf("%d \n",x->item);
    
    return 0;

    }
}

    #+end_src>

    
****** 链表练习题-part1

******* 1. 获取循环链表节点数的函数(3.24)
	#+begin_src c++
	int getLinkCount(link plink){
	int i = 1;
	link tmp = plink;// 临时变量存储初始值，然后循环对比
	while (plink != tmp->next)
	{
	 i++;
	 tmp = tmp->next;// 移动一位
	   
	}
	    return i;
	    })
	}
	#+end_src>
	
******* 2. 获取循环链表之间的节点数(3.25)
	#+begin_src c++
	int getTwoLinkLength(link x, link t) {
	    // 返回的是 x-t之间的距离，还有t到x之间的距离没有计算
	int m = 0;
	while (x->next != t)
	{
	    m++;
	    x = x->next;

	}
	    return m;
	    })
	}
	#+end_src>

******* 3. 两个链表插入合并（3.26）
#+begin_src c++
void mergeTwoCircleLink(link x, link t) {
 // 把链表从x处断开
link xNext = x->next;
 x->next = t;
//需要找到t的pre
		
}
#+end_src>
**** 栈--Stack

**** 树--tree



| kgj  | kgj  |
|------+------|
| kjg  | jkg  |
| jkg  | kjkg |
| kjkg |      |
