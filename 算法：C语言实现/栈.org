** stack定义
数据实现先进后出的的一中数据类型，可以使用数组和链表实现；栈并没有什么特殊的，只是使用方式不同而已

** 表达式前后缀
数学计算表达式有前缀，中缀和后缀之分，常见的就是中缀，计算符号在两个数字之间，后缀就是在之后；
+ =5 * (9+3)= 中缀表达式
+ =5 9 3 + *= 后缀表达式和上面等价


** 后缀表达式求值
#+begin_src c
// 只能计算10以内的后缀表达式
  int main(int argc,char *argv[]) {
      char *end = "534*+";
      int N = strlen(end),i;
      STAKinit(N);
      for (i=0; i<N; i++) {
	  if (end[i] == '+')
	      STAKpush(STACKpop() + STACKpop());
	  if (end[i] == '*')
	      STAKpush(STACKpop() * STACKpop());
	  if (end[i] >= '0' && end[i] <= '9')
	      STAKpush(end[i] - '0');
      }
      printf("%d \n",STACKpop());
  }
#+end_src
** 程序4.3 中缀后缀转换
中缀后缀转换遵循下面的思路
+ 从左到右读取中缀表达式
+ 左括号忽略
+ 数字直接输出
+ 符号入栈
+ 右括号操作符号出栈

#+begin_src c
// 表达式也有特殊的要求，部分必须要使用括号括起来，符号数量和
// 括号数量必须相等才能pop出所有的符号
int main(int argc,char *argv[]) {
    char *mid = "((5+(3*4))+(2*3))";
    int N = strlen(mid),i;
    STAKinit(N);
    for (i=0; i<N; i++) {
        if (mid[i] == '(')
            continue;
        if (mid[i] == '+' || mid[i] == '*')
            STAKpush(mid[i]);
        if (mid[i] == ')')
            printf("%c ",STACKpop());
        if (mid[i] >= '0' && mid[i] <= '9')
            printf("%c ",mid[i]);
    }
    printf("\n");


}
#+end_src>


** ADT数据结构

*** adt定义
#+begin_src c
// 初始化
void STAKinit(int);
// 判读是否为空
int STACKempty(void);
// 放入一个元素
void STAKpush(Item);
// 弹出一元素
Item STACKpop();
#+end_src>

*** 数组实现
#+begin_src c
typedef int Item;
static int *s;
static int N;
// 初始化 maxN个数组，N代表初始化的指针；
void STAKinit(int maxN) {
  s =   malloc(maxN * sizeof (Item));
  N = 0;

}
// 判读是否为空
int STACKempty(void) {
    return N == 0;
}
// 放入一个元素
// N==0代表是空的此时可以放入元素，N是下标的+1，而且可以表示元素个数
void STAKpush(Item item) {
    s[N++] == item;
}
// 弹出一元素
Item STACKpop() {
    return s[--N];//N刚好大下标一个数字
}

#+end_src>

*** 链表实现k
#+begin_src c
typedef int Item;
typedef struct node *link;
struct node{
    Item item;
    link next;
};
static link head;
// 初始化
void STAKinit(int) {
    head = NULL;
}
link NEW(Item item,link next) {
    link x = malloc(sizeof *x);
    x->item = item;
    x->next = next; // 将x节点放到了最新节点的前面
    return x;
}
// 判读是否为空
int STACKempty(void) {
    return head == NULL;
}
// 放入一个元素
void STAKpush(Item item) {
    head = NEW(item,head);
}
// 弹出一元素
Item STACKpop() {
    Item item = head->item;
    link t = head->next;
    free(head);
    head = t;
    return item;
}
#+end_src>


** 练习题

*** part1
1) 4.18,数组实现的栈运行后栈前5个数据的内容s[0] - s[4]
   #+begin_src c
    / 数组实现栈
    typedef char Item;
    static int MaxN = 100;
    static char *stack;
    static int N;
    void STACKinit(Item n) {
	stack = malloc(MaxN*(sizeof(Item)));
	N = 0;
    }
    void STACKpush(Item item) {
	stack[N++] = item;
    }
    Item STACKpop() {
	return stack[--N];
    }
    int STACKempty() {
	return N == 0;
    }

    int main(int argc,char *argv[]) {
	char *s = "LA*STI*N*FIR*ST**OU*T*******";
	int len = strlen(s);
	STACKinit(MaxN);
	for (int i=0; i<len; i++) {
	    if (s[i] == '*')
		printf("%c",STACKpop());
	    else
		STACKpush(s[i]);
	}
	printf("\n");
    int m = 4;
	while(m>=0)
	    printf("m{%d} %c ",m,stack[m--]);

    }
   #+end_src
2) 4.19,empty函数改为count函数，计算剩余的数量
    #+begin_src c
    // 数组实现
    int count(){
	return N;//N就代表了stack中剩余的元素数量
    }
    // 链表实现
    int count() {
    int c = 0;
    link t = head;
    while (t != NULL) {
	t = t->next;
	c++;
	}
	return c;
    }
    #+end_src>
3) 4.20,数组实现的栈POP为空push为满添加STACKerror函数
    #+begin_src c
    void STACKError(int flag) {
	if (flag == 0)
	    printf("stack is empty,pop error");
	else
	    printf("push out of bounds");
    }
    void STACKpush(Item item) {
	if (N > MaxN)
	    STACKError(1);
	stack[N++] = item;
    }
    Item STACKpop() {
	if (N<0)
	    STACKError(0);
	return stack[--N];
    }
    #+end_src>


* TODO 本章和第一章联系算法：连通性，二分算法


** 队列
队列是和栈相似的一种数据结构，但是符合FIFO，先进先出的特性；

** ADT数据结构
#+begin_src c
  void QUEUEinit(int);
  int QUEUEempty();
  void QUEUEput(Item);
  Item QUEUEget();
#+end_src

*** 链表实现
=维护一个头部链接用来删除，维护一个尾部链接用来插入=

#+begin_src c
// queue implements for link;
typedef int Item;
typedef struct node *link;
struct node{
    Item item;
    link next;
};

static link queuq, head,tail;
void QUEUEinit(int) {
    queuq = NULL;
    head = queuq;
    tail = queuq;
}

int QUEUEempty() {
    return queuq->next == NULL;
}

void QUEUEput(Item item) {

    link t = malloc(sizeof *t);
    if (queuq == NULL) {
	head =t;
	queuq = t;
	tail = t;
	t->item = item;
    } else {
	t->item = item;
	tail->next = t;
	queuq = t;
	tail = t;
    }

}
Item QUEUEget() {
    link t = head;
    head = head->next;
    int item = t->item;
    free(t);
    printf("%d\n",item);
    return item;
}

int main(int argc,char *argv[]) {
    QUEUEinit(3);
    for (int i=0; i<10; i++) {
	QUEUEput(i);
    }
    while (queuq != NULL)
	QUEUEget();
}
#+end_src>

*** 数组实现
=保存一个头部index用来删除，尾部index用来插入，走到末尾循环到头部继续=

#+begin_src c


#+end_src>
