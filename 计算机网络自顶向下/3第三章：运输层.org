* 3.1 概述运输层服务
运输层是介于应用层和网络层的中间，负责把应用层的消息转移给网络层；
网络路由器仅作用于数据报的网络层字段；不检查封装的字段； /*在接收端，网络层把数据提取出运输层报文段，交给运输层*/

1. 协议有哪些
   #+begin_quote
   运输层是 OSI（开放系统互联）模型中的第四层，主要负责在网络中不同主机之间提供端到端的通信。两个最常用的运输层协议是传输控制协议（TCP）和用户数据报协议（UDP）。这两者之间有一些关键的区别：

    1. 传输控制协议（TCP）：
    + 提供可靠的、面向连接的通信。
    + 使用三次握手建立连接，四次挥手终止连接。
    + 提供流控制、拥塞控制、错误检测和纠正等功能。
    + 数据按顺序传输，保证数据的可靠性。
    + 适用于需要可靠传输的应用，如文件传输、电子邮件、网页浏览等。
    2. 用户数据报协议（UDP）：
    + 提供无连接的通信。
    + 不保证可靠性，不进行连接建立和终止，也没有流控制和拥塞控制。
    + 数据传输更加快速，适用于实时应用，如音频和视频流。
    + 适用于一些简单的应用，对于可靠性要求不高的情况。

    除了TCP和UDP之外，还有一些其他运输层协议，但它们在实际应用中较为罕见。以下是一些其他的运输层协议：

    1. 传输层安全协议（TLS）：
    +  TLS是在TCP基础上的一层安全协议，用于保护数据的机密性和完整性。
    2. 常用于安全的Web浏览（HTTPS）。
    3. 数据报传输协议（DTP）：
    + 一种无连接的传输协议，类似于UDP，但用于支持多媒体数据的传输。
    4. 流控制传输协议（SCTP）：
    + 一种面向连接的协议，具有更多的特性，如多宿主和流控制。
    + 通常用于电话和VoIP等应用。

    总体而言，TCP和UDP是运输层中应用最广泛的两种协议，选择哪种取决于应用的需求，是更强调可靠性和有序性，还是更强调实时性和效率。
   #+end_quote


** 3.1.1 运输层和网络层的关系
=网络层提供了主机之间的逻辑通信，运输层提供了不同主机上的进程之间的逻辑通信=
网络层负责把信息从不同主机之间转换，运输层负责把信息给端系统上面的进程，因此需要port端口号；运输层负责把信息给端系统上面的进程只负责
端系统；

** 3.1.2 因特网运输层概述
+ 运输层的分组称为 =报文段（segment）= ，RFC文档中把TCP分组称为报文段，UDP分组称为 =数据报（data gram）=
+ 网络层使用的 *IP协议* 是不可靠协议
+ =UDP，TCP最基本的责任是，将两个端系统间的IP的交付服务扩展为端系统间两个进程间的交付服务=
+ 将主机间交付服务扩展为进程间交付服务称为 =运输层的多路复用= 与 =多路分解=
+ TCP提供可靠数据传输；通过使用流量控制、序号、确认和定时器，TCP还提供 =拥塞控制=
+ UDP提供不可靠数据传输

** 3.2 多路复用与多路分解
=多路复用= ：在源主机从不同套接字中手机数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段
传递到网络层，所有这些工作称为多路复用；
=多路分解= ：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解；
*整体情况就是：端系统会有多个进程（浏览器、邮件、FTP），多个socket，网络层是把多个socket进行一起运输，就像邮件车，到达目的端系统由根据socket进行分解，传输给对应的套接字*

#+caption: 多路复用不同层级
#+begin_quote
1. 传输层多路复用：
    在传输层（主要是TCP协议），多路复用通过使用不同的端口号来实现。一个计算机上的多个应用程序可以同时与另一台计算机建立多个TCP连接，
    每个连接使用不同的端口号。这些端口号用于标识不同的应用程序或通信流。
    例如，一个计算机上可能同时运行着 Web 浏览器、电子邮件客户端和文件下载器。每个应用程序可以使用不同的端口号，
    Web 浏览器使用端口号 80，电子邮件客户端使用端口号 25，文件下载器使用端口号 8080。
    这样，这些通信流就可以在同一个网络连接上进行多路复用。

2. 应用层多路复用：
    在应用层，多路复用可以通过在应用层协议中定义多路复用的机制。一个常见的例子是 HTTP/1.1 的持久连接（Keep-Alive）。在 HTTP/1.1 中，一个 TCP 连接可以被多次使用，而不需要在每次请求之后关闭连接。这样，多个 HTTP 请求和响应可以在同一个 TCP 连接上复用，而无需每次都建立新的连接。

    应用层多路复用的实现还包括一些其他的机制，例如 WebSocket 协议，它允许在单个 TCP 连接上进行全双工通信，
    使得服务器和客户端可以在同一连接上同时发送和接收数据。

总体而言，多路复用允许多个通信流在同一个连接上共享网络资源，提高了网络的效率和性能。这对于减少连接建立和断开的开销，以及降低网络延迟都是有益的。
#+end_quote

#+caption: 多路复用和多路分解
#+begin_quote
在网络通信中，多路复用（Multiplexing）和多路分解（Demultiplexing）是为了有效地在网络上传输多个通信流而采用的机制。这些概念通常涉及到端口和套接字的使用。
以下是一些常见的网络通信中的多路复用和多路分解的情境：
多路复用（Multiplexing）：

端口号： 在网络通信中，一个计算机可以同时运行多个应用程序，每个应用程序都需要与网络进行通信。这时就使用了端口号。
多路复用通过使用不同的端口号来将多个通信流合并到一个网络连接中。


例如，当你使用浏览器访问网页时，同时可能有其他应用程序也在进行网络通信（例如邮件客户端或文件下载器）。
每个应用程序使用不同的端口号，这样操作系统就能够正确地将数据传送到相应的应用程序。


传输层协议的端口： 在TCP和UDP协议中，端口号用于标识不同的应用程序或服务。在一个主机上，
同一时间可以有多个应用程序通过不同的端口号与网络通信。

例如，HTTP通信通常使用TCP协议的端口80，而HTTPS通信使用端口443。这样，多个网络应用程序可以通过不同的端口号使用同一个网络连接。



多路分解（Demultiplexing）：

端口号的使用： 多路分解是在接收端将多路复用的数据分离到不同的应用程序的过程。操作系统根据端口号将数据正确地传递给相应的应用程序。

例如，当服务器接收到一个TCP连接时，通过检查目标端口号，操作系统能够确定这个连接是为哪个应用程序服务的，
然后将数据传递给相应的应用程序进行处理。

套接字（Socket）： 在网络编程中，套接字是一种通信机制，它包含了IP地址和端口号，使得应用程序可以通过网络进行通信。
多路分解通过不同的套接字将数据传递给相应的应用程序。


例如，在一个服务器上运行的多个应用程序可能分别使用不同的套接字。当服务器接收到数据时，可以根据套接字信息将数据传递给正确的应用程序。

总体而言，多路复用和多路分解在网络通信中起到了关键的作用，使得一台计算机能够同时处理多个应用程序之间的通信。这有助于提高网络资源的利用率，同时确保数据能够准确地传递到相应的应用程序。
#+end_quote

1. 无连接的多路复用与多路分解-UDP
   =一个UPD套接字是由一个二元组全面标识的，该二元组包含一个目的IP地址和一个目的端口号=

   #+caption: 多路复用 
   [[file:imag/Snipaste_2023-12-01_00-40-49.png]]

2. 有连接的多路复用与多路分解-TCP
   =TCP使用四元组标识一个socket；源主机IP，源端口号，目的主机IP，目的端口号=
   #+caption: 多路复用 
   [[file:imag/Snipaste_2023-12-01_00-45-36.png]]

3. WEB服务器与TCP
   一般服务器使用一个80端口，通常是只有一个线程，没建立一个新的连接新建一个轻量级的线程；
   线程与socket不是一一对应的，就如80端口，可以为所有服务器线程公用；
   #+caption: 线程和socket端口对应关系
   #+begin_quote
  1. 多个进程共享套接字：
     多个进程可以共享同一个套接字。这通常发生在多进程服务器模型中，其中多个进程监听同一个套接字并处理连接。
  2. 一个进程拥有多个套接字：
      一个进程也可以创建多个套接字，每个套接字用于不同的通信目的。例如，一个服务器进程可能同时监听多个端口，每个端口对应一个套接字。
  3. 一对一连接：
     在某些情况下，一个套接字可能与另一个套接字建立一对一的连接。这通常发生在客户端和服务器之间的通信，其中一个套接字对应服务器，
     另一个对应客户端。
   #+end_quote

   *UDP不需要保持连接因此二元组足够了，TCP必须保持连接才使用4元组*

  



** 3.3 无连接运输：UDP
UDP仅能提供很少的工作：多路复用和分解，少量差错校验；不少场景下仍旧使用UDP，基于一下原因：

+ =关于发送什么数据及何时发送的应用层控制更为精细= TCP协议有拥塞控制，给出的报文不一定会立即发出，UDP就没有这个情况，报文会 *立即发出*
+ =无须建立连接= 没有连接的时延情况
+ =无连接状态= TCP需要控制连接状态，这会耗费更多的资源，UDP不必考虑这些，一些应用就可以支持更多的连接用户
+ =分组部首开销小= UDP首部仅有8个字节，TCP确需要20个字节；

  #+caption: 流行的因特网应用及其使用的运输协议
  | *应用*        | *应用层协议* | *下面的运输协议* |
  |--------------+------------+----------------|
  | 电子邮件       | SMTP       | TCP            |
  | 远程终端访问   | Telnet     | TCP            |
  | Web          | HTTP       | TCP            |
  | 文件传输       | FTP        | TCP            |
  | 远程文件服务器 | NFS        | 通常UDP         |
  | 流式多媒体     | 通常专用     | UDP或TCP        |
  | 因特网电话     | 通常专用     | UDP或tcp        |
  | 网络管理       | SNMP       | 通常udp         |
  | 名字转换       | DNS        | 通常udp         |
  
*** 3.3.1 UDP报文段结构
    #+caption: 报文结构图
    [[file:~/Documents/typora/计算机网络自顶向下/imag/udp2 (1).png]]

    
    #+caption: 报文结构图(2)
    [[file:~/Documents/typora/计算机网络自顶向下/imag/Snipaste_2023-12-01_22-46-57.png]]

*** 3.3.2 UDP校验和（checkSum）
这个是UPD中的数据准确性校验手段；规则如下
1) 将报文中的所有数据,分为16比特一组，所有组相加（除了校验字段之外）
2) 如果相加结果溢出16位，则进行回卷： =溢出位截取掉，剩余16位数字和截取位相加= 相当于是首位回卷到末尾
3) 最后结果进行取反码
4) 接收端拿到数据后俺同样的规则计算但是不取反码，这样得到的数字和校验数字的和就是 =1111 1111 1111 1111=

   + UDP协议有校验能力，但是没有数据恢复能力

   + 连同要运输的数据也一起进行了计算

   + java实现计算方法
     #+begin_src java
           public static void main(String[] args) {
        int len = args.length;
        int sum = 0;
        String arg[] = {"c0a8", "016a",
                "0b6f", "6f6f",
                "0011", "0011",
                "f83d",
                "3039",
                "0011",
                "6865", "6c6c", "6f20", "5544", "5000"};
        int size = arg.length;
        int  a = Integer.parseInt(arg[0],16);
        int  b = Integer.parseInt(arg[1],16);

        // 将十六进制字符串转换为字节数组
        for (int i=0; i<size; i++) {
            sum += Integer.parseInt(arg[i],16);
            if (sum >>> 16 != 0) {// 判断是否溢出
                sum = (sum >>> 16) + (sum & 0xffff); // 数据在底层按32位存放，这里取高16位和低16位相加，实现回卷
            }
        }

        // 打印转换后的字节数组内容
        System.out.println("sum = "+sum);
        System.out.println(Integer.toHexString(~sum).substring(4));
    }
     #+end_src

   + 实际例子
     [[file:imag/Snipaste_2023-12-01_23-30-38.png]]

     上图是UDP协议请求DNS的wireshar报文，解析如下：

     | key              | human             | hex                                                       |
     |------------------+-------------------+-----------------------------------------------------------|
     | source           | =10.1.2.175=      | 0a01 02af                                                 |
     | Destination      | =10.1.2.1=        | 0a01 0201                                                 |
     | Protocol         | UDP(17)           | 0011                                                      |
     | Length           | 43                | 002b                                                      |
     | Source port      | 56351             | dc1f                                                      |
     | Destination port | 53                | 0035                                                      |
     | Length           | 43                | 002b                                                      |
     | CHecksum         | 7a3f              | 7a3f                                                      |
     | Data             | www.jetbrains.com | 0377 7777 096a 6574 6272 6169 6e73 0363 6f6d 0000 0100 01 |
     |                  |                   |                                                           |

0000   30 ae 7b e7 19 13 bc d0 74 46 f5 1c 08 00 45 00   0.{.....tF....E.
0010   00 3f 4d 76 00 00 40 11 14 87 *0a* 01 02 af 0a 01   .?Mv..@.........
0020   02 01 dc 1f 00 35 00 2b 7a 3f fe 64 01 00 00 01   .....5.+z?.d....
0030   00 00 00 00 00 00 03 77 77 77 09 6a 65 74 62 72   .......www.jetbr
0040   61 69 6e 73 03 63 6f 6d 00 00 01 00 01            ains.com.....

     
     



** 3.4 可靠数据传输原理
#+begin_quote
  可靠数据传输是指在计算机网络中确保数据在发送和接收之间进行可靠、完整、准确传输的机制或协议。在数据通信过程中，由于网络中可能存在各种问题，比如噪声、拥塞、丢包、延迟等，这些问题可能导致数据的丢失、损坏或顺序错乱。因此，可靠数据传输的目标是确保数据的完整性和准确性，使数据能够按照预期的方式被正确地传输和接收。
可靠数据传输通常包括以下特性和机制：
1. 确认和重传机制：
    发送方发送数据后，接收方会发送确认信息，表明已成功接收数据。
    如果发送方在合理的时间内未收到确认，将重新发送数据。
2. 序列号和确认号：
    序列号用于标识数据包的顺序。
    确认号用于指示下一个期望接收的数据包序列号。
3. 超时重传：
    发送方设置一个超时计时器，如果在设定的时间内未收到确认信息，就会重新发送数据包。
4. 流量控制：
    控制发送方发送数据的速率，以避免数据包的丢失和网络拥塞。
5. 错误检测和纠正：
    使用校验和、循环冗余校验（CRC）等技术对数据进行检验，以发现和纠正传输中可能发生的错误。
6. 顺序控制：
    确保接收方按照发送方的顺序接收数据，以避免数据包乱序。
7. 流水线处理：
    允许同时存在多个数据包在传输途中，以提高传输效率。
8. 选择性重传：
    仅重新发送丢失或损坏的数据包，而不是整个数据流。

这些机制和特性通常被TCP（传输控制协议）等协议所采用，TCP是一个提供可靠数据传输的面向连接的协议，在互联网上广泛使用。
相比之下，UDP（用户数据报协议）是无连接的、不可靠的传输协议，不提供上述的可靠数据传输特性。选择使用哪种协议取决于应用场景的需求。
#+end_quote

[[file:imag/Snipaste_2023-12-14_10-13-50.png]]
这是可靠传输的基本模型，应用层两个进程间进行交互数据，依赖运输层的可靠信道；这里运输层需要依赖网络层，而网络层的传输是不可靠的，如何构建一个可靠的数据传输模型呢？


*** 3.4.1 构建可靠的数据传输协议

=rdt= 表示可靠数据传输， =udt= 表示不可靠数据传输；rdt_send是可靠数据发送；
   #+begin_quote
   图片理解：这是一个有限状态机的表示图
   1) 虚线表示开始
   2) 圆圈表示一个状态
   3) 带箭头的实线表示状态的跃迁（转化），边上的横线表示变化发生的条件， =横线上方= 是发生的条件， =横线下方= 是发生的的动作
   #+end_quote

1. 完全可靠的数据传输rdt1.0
   #+caption: rdt1.0协议
   [[file:imag/Snipaste_2023-12-14_10-23-21.png]]

   1) 发送端动作
      等待上层的调用（浏览器等的发送动作），当发生调用时（rdt_send）首先是制作数据包，然后调用udt_send，通过网络层进行发送
      动作执行完之后，状态仍旧是等待上层的调用，没有进行变化

   2) 接收端动作
      接收端是等待下层的调用，到达应用层；发生的事件是接收到数据包，执行的动作首先是提取数据包，然后对数据包进行分发。
      动作执行完后，状态仍旧没有改变，继续等待下层的调用

   3) 结论
      该模型是一个完美的模型，因为发送和接收都没有错误，因此不需要反馈；这里假定了发送方的速率和接收方是匹配的，没有进行考虑。

2. 经具有bit差错的可靠数据传输：rdt2.0
   实际的情况是数据发送，传播，缓存的过程中会受损，bit可能会进行反转，这里假设数据包的顺序是正确的.
   在电话通话过程中当我们明白对方的意思，可能会说好的或者ok表示知道了，如果没有听清楚就会说请再说一遍，这样有 *肯定确认* *否定确认* *重复发送* 的协议
   称为 =自动重传协议ARQ= 自动重传需要三种协议功能来处理bit差错
   1) */差错检测/* 。和前面的checksum一样，会有一种检测技术来确定数据包是否发生了bit差错

   2) */接收方反馈/* 。接收方和发送方通信相隔几千公里，需要通过接收方的反馈来确认是否获取到正确的数据包； *ACK肯定确认* *NAK否定确认*

   3) */重传/* 。接收到错误分组时，发送方重新发送数据包

   4) 协议例子
    #+caption: rdt2.0 FSM示意图
    [[file:imag/Snipaste_2023-12-14_11-39-01.png]] 

    #+caption: 2.0图片解释
    #+begin_quote
    1) 发送端动作
	初始状态是等待上层调用，然后发送数据包，之后状态变为等待ACK或NAK回复；等待回复状态会发生两个情况，收到ACK或者NAK
	收到NAK表示发生了bit错误，这时会重新发送数据包然后仍旧是等待回复状态；
	收到ACK表示数据包正确接收，这时一个包就正确发送，等待上层的继续调用，状态改变。
    2) 接收端动作
	初始状态是等待下层的调用，接收方只有一个状态，但是多了一个确认动作；当接收到数据包并且检测到发生错误（corrupt），会发送一个NAK确认然后继续等待包到来
	同样接收到正确的数据会回复一个ACK包，然后继续等待包。
    3) rdt2.0发送端发送后就进入了等待状态，此时不会进行数据发送，这样的协议称为 *停等协议* ；该协议有一个致命缺陷，就是接收方的反馈数据也会发生bit错误；
	如果一个NAK信息变为来ACK就导致了一个错误的数据包发生了；此时会有如下三种情况
	+ 发送方不能确定ACK或NAK，接收方回复也容易错误，即双方发送都会出错，这样就没有确定行了
	+ 增加足够的校验bit，不仅可以检测错误，也能够对错误进行恢复，这样当信道不丢失分组时，可以得到正确的答案，就没有问题了
	+ 收到错误反馈时，直接重发分组，这样会产生 *冗余分组*
    4) 通用处理办法
	对于3中的一些问题，现在一般采用添加 *序号* 的方式来解决；即添加一个序号字段给包进行区分；
	    #+end_quote

    #+caption: rdt2.1 有ACK和NAKFSM示意图(sender)
    [[file:imag/Snipaste_2023-12-14_14-56-51.png]]
    #+caption: rdt2.1 有ACK和NAKFSM示意图(receiver)
    [[file:imag/Snipaste_2023-12-14_14-58-47.png]]

    #+caption: rdt2.2 没有NAKFSM示意图(sender)
    [[file:imag/Snipaste_2023-12-14_15-00-15.png]]
    #+caption: rdt2.2 没有NAKFSM示意图(receiver)
    [[file:imag/Snipaste_2023-12-14_15-01-37.png]]

3. 具有bit差错和分组的丢失的可靠数据传输：rdt3.0
需要一个定时器用来确定发送是否超市，如果超时则提供重发服务；
[[file:imag/Snipaste_2023-12-19_23-27-09.png]]   

 rdt3.0是一个bit交替协议，发送等待反馈
 [[file:imag/Snipaste_2023-12-19_23-29-48.png]]







*** 3.4.2 流水线可靠数据传输协议

rdt3.0的确可以保证数据可靠，但是没法保证传输的速率，这样太过于浪费网络

发送一个分组等待结果然后发送下一个分组。使网络的利用率过低，没法有效使用，因此引入了流水线技术，就是一次发送一部分分组，等待结果然后发送下一组
有以下要求：
+ 这样要求对数据包进行更大的编号，方便区分
+ 两边也要缓存分组，方便重传和区分
+ 处理错误，有两种方式 =回退N步(GBN,go-back-N)= 和 =选择重传(Select repeat,SR)=

*** 3.4.3 回退N步

[[file:imag/Snipaste_2023-12-20_00-27-13.png]]

发送数据可以分为四部分
1) 已发送并确认
2) 发送未确认
3) 可发送还未发送
4) 不能发送

   *其中2和3加在一起长度N称为窗口长度*

   [[file:imag/Snipaste_2023-12-20_00-30-24.png]]

   [[file:imag/Snipaste_2023-12-20_00-31-08.png]]


回退N步的原理是，发送发遇到失序ACK（n未确定，n+1确认）或者超时，则会全部重发最小未确定n和后面的数据
接收方也会丢弃失序的接收数据，反正后面还会重发一次；

*** 3.4.4 选择重传
[[file:imag/Snipaste_2023-12-20_00-38-32.png]]

[[file:imag/Snipaste_2023-12-20_00-39-04.png]]


[[file:imag/Snipaste_2023-12-20_11-38-41.png]]

** 3.5 面向连接的运输TCP

TCP是一个可靠传输协议，运用了里面的很多原理包括：差错检测、重传、累计确认、序号、确认号、定时器等；


*** 3.5.1 TCP连接
TCP是面向连接的，因为提前必须先进行握手；TCP连接的确认是 =逻辑连接= 就是告知对方一些情况就算是连接上了，并不需要维持一个通信链路；客户端告诉服务器我要进行连接
服务器告诉客户端我知道了，这就是建立了连接，因此是逻辑性的；
=MSS（Maximum Segment Size）最大报文段长度= 是指数据报承载应用层数据的长度，并不包含TCP报文的首部字段，TCP/IP首部长度一般为40字节，MTU一共1500字节，因此
MSS一般是1460字节；

*** 3.5.2 TCP报文段结构
[[file:imag/Snipaste_2023-12-28_14-37-56.png]]

+ 16bit源端口号和16bit目的端口号，port最大值是65535 16bit刚好
+ 32bit =序号字段= 和 =确认号字段=
+ 16bit =接收窗口= 用于流量控制
+ 4bit =首部字段= 首部字段一般情况是不变的，但是option如果有数据就会不一样，一般情况下为20byte
+ =选项字段= 用来双方协商最大报文长度MSS或这窗口调节因子
+ 6bit标志位
    + URG（URGent）： 表示紧急指针是否有效。
    + ACK（ACKnowledgment）： 指示确认号字段是否有效。
    + PSH（PuSH）： 提示接收端应立即交付数据给应用程序。
    + RST（ReSeT）： 用于重置连接。
    + SYN（SYNchronize）： 发起一个连接请求。
    + FIN（FINish）： 表示发送方已经完成发送数据

1. 序号和确认号
   TCP把数据看成一个结构，有序的字节流；整个待传送的文件看成一个有序的字节流，序号指代的是整体序列的首字节号，根据MSS可以确定下一个序号，如果seq=100，MSS=100
   那么下一个seq=201；
   [[file:imag/Snipaste_2023-12-28_15-10-39.png]]

   ACK是什么呢，是客户端或服务器需要的下一个字节的号；
   [[file:imag/Snipaste_2023-12-28_15-28-48.png]]



*** 3.5.3 往返时间和超市重传

*** 3.5.4 可靠数据传播

*** 3.5.5 TCP连接管理

**** tcp连接
TCP连接过程分三步
1. =SYN报文段= 第一步是客户端发送一条特殊的报文到服务器，这条报文不携带数据， =SYN = 1= 这是请求连接，同时会随机设置一个序号seq；
2. =SYNACK报文段= 第二步是服务器返回，接收到SYN报文段后，服务器进行解析，为该次请求的连接分配缓存，返回数据 =syn=1= =ACK是client_seq+1=
   选择自己的初始序号seq；
3. =ACK报文段= 客户端收到第二步中的报文段后，分配缓存和设置变量，返回的 =ACK是server_isn+1= =SYN=0= =seq=client_isn+1= ;


[[file:imag/Snipaste_2023-12-29_15-00-38.png]]

#+caption: 三次握手值的变化
| 操作   | SYN | client_isn    | ACK          | server_isn    |
|-------+-----+---------------+--------------+---------------|
| 第一次 |   1 | 随机client_isn | 无            | 无             |
| 第二次 |   1 | 无             | client_isn+1 | 随机server_isn |
| 第三次 |   0 | client_isn+1  | server_isn+1 | 无             |

为什么需要三次握手
握手的目的是为了确定双方可以通信，也就是双方都可以发送信息，接收信息且发送接收的信息对方可以接收，只要证明了这个就可以
+ 第一次握手：证明了client可以send message
+ 第二次握手：证明了server可以send message，证明了server可以receive message；
+ 第三次握手：证明了client可以receive message，
上面的三步刚好证明双方都有接收和发送能力；

*连接过程示例*
[[file:imag/Snipaste_2023-12-29_15-18-06.png]]
这是一个SSH连接过程，前面先进行了tcp网络连接；分别是两个端口58593和22（SSH默认端口）
第一个是syn，然后是SYNACK，最后是ACK

**** tcp断开
TCP的断开过程分四步进行，首先是客户端发起断开请求 =FIN-1= 然后服务器返回 ACK，再是服务器发起断开，服务器进行确认；

[[file:imag/Snipaste_2023-12-27_17-27-18.png]]

[[file:imag/Snipaste_2023-12-27_17-25-14.png]]

1. 过程描述
   + 第一步由client发起断开请求，然后进入 *FIN-WAIT-1* 阶段
   + 第二步server收到请求，发送ACK，进入 *CLOSE-WAIR* 阶段，client收到ACK进入 *FIN-WAIR-2* 阶段
   + 第三步server发送FIN，进入 *LAST-ACK* 阶段，clent收到fin进入 *TIME-WAIT* 阶段
   + 第四步client发送ACK，进入等待计时，如果没有收到FIN重传，就会close，server收到ACK后执行close
2. 为什么需要四步，二三步不能合并吗？
   + 二三步不能合并，server收到FIN请求，需要做一些善后工作才行，有可能自己要发送到client的数据还没传完
     或者需要和上层Application进行交互，准备断开工作
   + 二三步不能省略，二三步中间是间隔一大段时间完成的，不能合并
   + 断开是双方约定的过程，你告诉我进行断开，我反馈知道这个消息，我告诉你要断开
     你反馈收到消息，这样双方都确定后断开，不会形成clent没有断开，发送请求告知没法连接
     server没有断开，等待client发送消息，浪费资源的情况
3. *实际例子*
   terminal连接remote server SSH protocol
   [[file:imag/Snipaste_2023-12-29_16-13-50.png]]
   断开过程分了四步进行，client发起；

*** QUESTIONS
1. tcp数据流序号seq和ACK含义
2. 连接的三次握手过程
3. 断开连接过程
4. 断开为什么要4次


** 3.6 拥塞控制

** 3.7 TCP拥塞控制

* chapter question
1. 什么是运输层，有什么特点

2. 可靠运输协议需要什么

3. TCP和UDP区别
