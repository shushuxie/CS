** 数据抽象
就像过程一样可以实现复用构造更加抽象的,高阶的过程,甚至还能返回过程; 同样数据也可以实现高阶数据抽象;
使用基本的运算构造出更加高阶的运算; 层层抽象.

** 2.1 数据抽象导引
***** 过 *选择函数* 和 *构造函数* 构建出一个复合数据结构; 每层只管使用当前的类型就好不用考虑别的影响.

*** 2.1.1 实例: 有理数的算数运算
我们定义一个新的有理数的表示计算方式,一个有理数的表示方式是通过 =分子/分母= 得到的.下面我们定义三个过程

     - =(make-rat <n> <d>)= 返回一个有理数,分子是整数呢n,分母是整数d;
     - =(number <x>)= 返回有理数x的分子
     - =(denom <x>)= 返回有理数x的分母


  
**** 基本运算的表示
~现在并不去考虑上面三个函数的实现方式,假设我们已经实现了上面的函数~ 这是一种称为 *按愿望思维* 的方式方式
#+begin_latex
\begin{align}
    &  \frac{\boldsymbol{n_{1}}}{\boldsymbol{d_{1}}} + \frac{\boldsymbol{n_{2}}}{\boldsymbol{d_{2}}} = \frac{\boldsymbol{n_1}\boldsymbol{d_2}+\boldsymbol{n_2}\boldsymbol{d_1}}{\boldsymbol{d_1}\boldsymbol{d_2}} \\ % add
    &  \frac{\boldsymbol{n_{1}}}{\boldsymbol{d_{1}}} - \frac{\boldsymbol{n_{2}}}{\boldsymbol{d_{2}}} = \frac{\boldsymbol{n_1}\boldsymbol{d_2}-\boldsymbol{n_2}\boldsymbol{d_1}}{\boldsymbol{d_1}\boldsymbol{d_2}} \\ % sub
    &  \frac{\boldsymbol{n_{1}}}{\boldsymbol{d_{1}}} \cdot \frac{\boldsymbol{n_{2}}}{\boldsymbol{d_{2}}} = \frac{\boldsymbol{n_1}\boldsymbol{n_2}}{\boldsymbol{d_1}\boldsymbol{d_2}} \\ % mul
    &  \frac{\frac{\boldsymbol{n_1}}{\boldsymbol{d_1}}}{\frac{\boldsymbol{n_2}}{\boldsymbol{d_2}}} = \frac{\boldsymbol{n_1}\boldsymbol{d_2}}{\boldsymbol{d_1}\boldsymbol{n_2}} \\ % div
    &  \frac{\boldsymbol{n_1}}{\boldsymbol{d_1}} = \frac{\boldsymbol{n_2}}{\boldsymbol{d_1}} \iff \boldsymbol{n_1}\boldsymbol{d_2} = \boldsymbol{n_2}\boldsymbol{d_1} % if and only if
\end{align}
#+end_latex

**** 规则表示为相应的过程

#+caption: 加法
#+begin_src emacs-lisp
  (defun add-rat (x y)
      (make-rat (+ (* (number x) (denom y))
                   (* (number y) (denom x))) ;分子
                (* (denom x) (denom y)))) ;分母

#+end_src

#+caption: 减法
#+begin_src emacs-lisp
  (defun sub-rat (x y)
    (make-rat (- (* (number x) (denom y))
		 (* (number y) (denom x)))
	      (* (denom y) (denom x))))
#+end_src

#+caption: 乘法
#+begin_src emacs-lisp
  (defun mul-rat (x y)
    (make-rat (* (number x) (number y))
	      (* (denom x) (denom y))))
#+end_src

#+caption: 除法
#+begin_src emacs-lisp
  (defun div-rat (x y)
    (make-art (* (number x) (denom y))
	      (* (denom x) (number y))))
#+end_src

#+caption: 相等
#+begin_src emacs-lisp
  (defun equal-rat? (x y)
    (= (* (number x) (denom y))
       (* (denom x) (number y))))
#+end_src

#+caption: 举例
#+begin_latex

$$fdjsk$$ veui 
$E=M^3$ haha 
$E=M^3$ haha 

\begin{equation*}

$E = m^2$ 这是一个行内公式

$$E=MC^2$$

	\[ \sum_{i=1}^{n} i = \frac{n(n+1)}{2} \]


$$
\int_{0}^{\infty} e^{-x^2} dx = \frac{\sqrt{\pi}}{2}
$$

\[ x = \textcolor{red}{\Large \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}} \]

					\begin{align*}
					f(x) &= \int_{-\infty}^x e^{-t^2} dt \\
					g(x) &= \sum_{n=0}^\infty \frac{f^{(n)}(0)}{n!} x^n
					\end{align*}

$e=mc^2$ 

					$$e=mc^2$$


\begin{array}{l}   a\mathop{{x}}\nolimits^{{2}}+bx+c=0 方程有两个不相等的是跟\\   \Delta =\mathop{{b}}\nolimits^{{2}}-4ac \\   \left\{\begin{matrix}   \Delta \gt 0\text{方程有两个不相等的实根} \\   \Delta = 0\text{方程有两个相等的实根} \\   \Delta \lt 0\text{方程无实根} \end{matrix}\right.    \end{array} 

这是一个行间公式：
$$
E=mc^2
$$ gjdkrwe



$$E=E^3$$


 \(hahdfdsdf\) 

\begin{equation}                        % arbitrary environments,
x=\sqrt{b} \text{方程有两个不相等的实根}   % even tables, figures, etc
\end{equation} 

If $a^2=b$ and \( b=2 \), then the solution must be
either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2} \].

 veui$abc$ fjdsk $$dfjsk$$ \(fjdskf\) 
 $hfds$ $gsdi$  dfs $fjdk$ gd哈哈

\begin{table}[htbp]
\centering
\caption{Example LaTeX Table}
\label{tab:example}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Column 1} & \textbf{Column 2} & \textbf{Column 3} \\ \hline
Row 1, Column 1   & Row 1, Column 2   & Row 1, Column 3   \\ \hline
Row 2, Column 1   & Row 2, Column 2   & Row 2, Column 3   \\ \hline
\end{tabular}
\end{table}
#+end_latex

#+caption: tupian
#+begin_example

[[file:~/Documents/typora/lisp/images/2024-06-19_23-52-09_screenshot.png]]

#+end_example





**** 序对
序对是lisp语言提供的一种数据结构,通过 *const* 关键字

    - cons只能有两个参数,称为点对
    - cons is ~construct~ 构造
    - car是寄存器的地址部分, ~Contents of Address part of Register~
    - cdr 是寄存器减量部分 ~Contents of Decrement part of Register~  

  
#+caption: base use
#+begin_src emacs-lisp
(setq x (cons 1 2))
(car x)
(cdr x)

#+end_src

#+caption: 嵌套用法
#+begin_src 
(setq x (cons 1 2)) 
(setq y (cons 3 4))
(setq z (cons x y))
(car (car z))
(cdr (cdr z))
#+end_src

**** 序对表示有理数

    #+begin_src emacs-lisp
    (defun make-rat (n d)
	(cons n d))

    (defun nmuer (x) 
    (cons car x))

    (defun denom (x)
	(cdr x))

    (defun print-rat (x)
    (newline)
    (princ (numer x))
    (princ "/")
    (princ(denom x))
    )


    #+end_src

    #+caption: GCD最大公约数
    #+begin_src emacs-lisp
    (defun GCD (a b)
	(if (= 0 b)
	    a
	    (GCD b (% a b))))
    #+end_src


    
**** 练习2.1
   =定义一个make-rat更好的版本可以处理,正数和负数,负数,分母为负数= 
   #+caption:  可以表示负数
   #+begin_src emacs-lisp
     (defun make-rat (n d)
	  (cons n d))

     (defun numer (x)
	 (abs (car x)));取绝对值

     (defun denom (x)
       (cond ((and (> (car x) 0) (> (cdr x) 0)) (cdr x))
	     ((and (> (car x) 0) (< (cdr x) 0)) (cdr x))
	     ((and (< (car x) 0) (> (cdr x) 0)) (-(cdr x)))
	     ((and (< (car x) 0) (< (cdr x) 0)) (-(cdr x)))
	     ))

     (setq test1 (make-rat -1 3))
     (numer test1)
     (denom test1)

   #+end_src


*** 2.1.2抽象屏障
    抽象屏障是这样的, 一层的数据依赖另一层的抽象, 例如: *cons --> make-rat --> add-rat --> 使用数据的程序* 

#+caption: 抽象屏障
[[file:~/Documents/typora/lisp/images/2024-06-22_12-13-25_screenshot.png]]

**** 练习2.2
#+caption:  练习2.2
#+begin_src emacs-lisp
  ;;; code
  (defun make-segment (start-point end-point)
    "定义表达式,嵌套序点"
    (cons start-point end-point))

  (defun start-segment (segment)
    "得到开始的点"
    (car segment))

  (defun end-segment (segment)
    "得到结束的点"
    (cdr segment))

  ;;;点的构造
  (defun make-point (x y)
    "构造一个点"
    (cons x y))

  (defun x-point (x)
    (car x))

  (defun y-point (x)
    (cdr x))

  (defun print-point (p)
    (newline)
    (princ "(")
    (princ (x-point p))
    (princ ",")
    (princ (y-point p))
    (princ ")")
    )

  (setq pa (make-point 3 6))
  (setq pb (make-point 2 8))
  (setq segment-a-b (make-segment pa pb))

  (print-point (start-segment segment-a-b)
  )

  (print-point (end-segment segment-a-b)
  )

#+end_src


**** 练习2.3
实现一种平面矩形的表示,构造和选择函数;

#+caption:  2.3
#+begin_src emacs-lisp

  (defun make-point (x y)
    "构造一个点"
    (cons x y))

  (defun x-point (x)
    (car x))

  (defun y-point (x)
    (cdr x))
  ;; 用一个复合的点表示矩形
  (defun ju-xing (x y)
    "矩形的表示,只需要两个个对角的点即可"
    (make-point x y))
  ;; 两个选择函数,确定长和宽
  (defun length (a)
    (abs (- (x-point (x-point a))
	    (x-point (y-point a)))))
  (defun weight (a)
    (abs (- (y-point (x-point a))
	    (y-point (y-point a)))))
  ;; 求矩形的面具 axb
  (defun mianji (a)
    (* (length a) (weight a)))
  ;; 求矩形的周长
  (defun circle-length (a)
    (* 2 (+ (length a) (weight a))))

  ;; 测试
  (setq x (make-point 2 4))
  (setq y (make-point 4 7))
  (setq a (ju-xing x y))
  (mianji a)
  (abs (- (x-point (x-point a)) (x-point (y-point a))))
  (y-point (x-point a))
  (y-point a)
  (abs (- (x-point (y-point a)) (y-point (y-point a))))

  (circle-length a)

#+end_src

*** 2.1.3 数据意味着什么
    数据到底是如何表示的,不仅是别的,同样也能够通过过程来表示数据,这样数据就是对象,对象是过程实现的;
    我们给自己定义的有理数下一个定义,对于任意的 ,n,d和选择函数,满足

    $$\frac{(numer\: x)}{denom\:x} = \frac{n}{d}$$
    只要满足这个公式就是我们定义的有理数,无论底层是如何实现的;

    #+begin_src elisp
    (setq lexical-binding t)

    (defun cons2 (x y)
    (lambda (m)
	(cond ((equal m 0) x)
	    ((equal m 1) y))))

    (defun car2 (z)
    (funcall z 0))

    (defun cdr2 (z)
    (funcall z 1))

    (setq test (cons2 24 23))

    (message "car: %d" (car2 test))  ; 输出 24
    (message "cdr: %d" (cdr2 test))  ; 输出 23
    #+end_src

    
**** 练习2.4
另一种表示形式
#+begin_src elisp
  (setq lexical-binding t)
   (defun cons2 (x y)
     (lambda (m) (funcall m x y)))

   (defun car2 (z)
     (funcall z (lambda (p q) p)))

   (defun cdr2 (z)
     (funcall z (lambda (p q) q)))

   (setq test (cons2 7 6))
   (car2 test)
   (cdr2 test)
#+end_src

#+caption: 代码解释,GPT
#+begin_src elisp
(define (cons x y)
(lambda (m) (m x y)))

当我们调用 (cons 3 4) 时，发生了什么？
创建闭包

cons 函数返回一个 lambda 表达式：

(lambda (m) (m x y))

在这个 lambda 表达式中，x 和 y 是 cons 函数的参数。当我们调用 (cons 3 4) 时，x 被赋值为 3，y 被赋值为 4。因此，lambda 表达式变为：

(lambda (m) (m 3 4))

这个 lambda 表达式是一个闭包，因为它“捕获”了构造它时的环境（即变量 x 和 y 的值）。所以，当 cons 返回这个 lambda 时，这个闭包携带了 3 和 4 这两个值。
car 的执行过程

现在我们来看看 car 是如何工作的：

scheme

(define (car z)
  (z (lambda (p q) p)))

当我们调用 (car pair)，其中 pair 是由 (cons 3 4) 得到的，具体的过程如下：

    构造 pair

    scheme

(define pair (cons 3 4))

这里 pair 被赋值为一个闭包：

scheme

(lambda (m) (m 3 4))

调用 car

scheme

(car pair)

这相当于调用：

scheme

(pair (lambda (p q) p))

执行闭包 pair

scheme

((lambda (m) (m 3 4)) (lambda (p q) p))

这个调用意味着我们把 (lambda (p q) p) 作为参数 m 传递给了闭包 pair，所以 m 被赋值为 (lambda (p q) p)。

执行传入的 lambda 表达式

scheme

(m 3 4)

即：

scheme

    ((lambda (p q) p) 3 4)

    这个 lambda 表达式忽略 q，返回 p，所以结果是 3。

总结

通过 (cons 3 4) 创建的闭包是 (lambda (m) (m 3 4))，它捕获了 3 和 4 这两个值。捕获的意思是，这个闭包在被调用时，始终会用 3 和 4 作为参数调用传入的函数。

这个过程确保了我们在 car 调用中能够提取出对的第一个元素。car 函数通过调用闭包，并传入一个返回第一个参数的 lambda 函数，实现了对第一个元素的提取。 (define (cons x y)
  (lambda (m) (m x y)))

当我们调用 (cons 3 4) 时，发生了什么？
创建闭包

cons 函数返回一个 lambda 表达式：

scheme

(lambda (m) (m x y))

在这个 lambda 表达式中，x 和 y 是 cons 函数的参数。当我们调用 (cons 3 4) 时，x 被赋值为 3，y 被赋值为 4。因此，lambda 表达式变为：

scheme

(lambda (m) (m 3 4))

这个 lambda 表达式是一个闭包，因为它“捕获”了构造它时的环境（即变量 x 和 y 的值）。所以，当 cons 返回这个 lambda 时，这个闭包携带了 3 和 4 这两个值。
car 的执行过程

现在我们来看看 car 是如何工作的：

scheme

(define (car z)
  (z (lambda (p q) p)))

当我们调用 (car pair)，其中 pair 是由 (cons 3 4) 得到的，具体的过程如下：

    构造 pair

    scheme

(define pair (cons 3 4))

这里 pair 被赋值为一个闭包：

scheme

(lambda (m) (m 3 4))

调用 car

scheme

(car pair)

这相当于调用：

scheme

(pair (lambda (p q) p))

执行闭包 pair

scheme

((lambda (m) (m 3 4)) (lambda (p q) p))

这个调用意味着我们把 (lambda (p q) p) 作为参数 m 传递给了闭包 pair，所以 m 被赋值为 (lambda (p q) p)。

执行传入的 lambda 表达式

scheme

(m 3 4)

即：

scheme

    ((lambda (p q) p) 3 4)

    这个 lambda 表达式忽略 q，返回 p，所以结果是 3。

总结

通过 (cons 3 4) 创建的闭包是 (lambda (m) (m 3 4))，它捕获了 3 和 4 这两个值。捕获的意思是，这个闭包在被调用时，始终会用 3 和 4 作为参数调用传入的函数。

这个过程确保了我们在 car 调用中能够提取出对的第一个元素。car 函数通过调用闭包，并传入一个返回第一个参数的 lambda 函数，实现了对第一个元素的提取。
#+end_src
**** 练习 2.5
#+begin_src emacs-lisp
;; This buffer is for text that is not saved, and for Lisp evaluation.
;; To create a file, visit it with , f f and enter text in its buffer.

(expt 2 3)

;; 0的表示
(defun zero ()
  (lambda (f)
    (lambda (x) x)))

;; 加1表示
(defun add-1 (n)
  (lambda (f)
    (lambda (x)
      (f ((n f) x)))))

;; one就是add-1 (zero)
(add-1 zero)

 (lambda (f)
   (lambda (x)
     "lambda f 返回一个匿名lambda （x）x"
     (f ((lambda f) x))));代换n

 (lambda (f)
   (lambda (x)
     "lambda (x) x 返回一个固定的值x"
     (f ((lambda (x) x) x))));

; one的定义
 (lambda (f) (lambda (x) (f (x))));

;;; two的表示
; 可以用add-1 和one 代换
(defun add-1 (n)
  (lambda (f)
    (lambda (x)
      (f ((n f) x)))))

; one 可以接收一个参数f,return a lambda 函数
 (lambda (f) (lambda (x) (f (x)))); one

 (lambda (f)
   (lambda (x)
     "one代入展开"
     (f (((lambda (f) (lambda (x) (f (x)))) f) x))));代入n


 (lambda (f)
   (lambda (x)
     "将f传入参数"
     (f ((lambda (x) (f (x))) x))));代入n

 (lambda (f)
   (lambda (x)
     "将x代入参数,返回 f （x）"
     (f (f (x)))));


 (lambda (f) (lambda (x) (f (f (x))))); 单行展示


;;; 区间计算练习
(defun upper-bound (source precent)
  "上界就是原始值加上误差值"
  (* source (+ 1.0 precent)))


(defun lower-bound (source precent)
  (* source (- 1.0 precent)))

;; 两个区间的差应该是最大值减去最小值

(defun sub-interval (x y)
  (make-interval ((abs (- (lower-bound x) (lower-bound y)))
		  (abs (- (upper-bound x) (upper-bound y))))))
#+end_src


** 2.2层次性数据和闭包性质
闭包是一个抽象代数概念，被用在了lisp当中，虽然不合适但是沿袭了下来；
就是 *某个函数和某个变量进行绑定，然后调用该函数能一直共用该变量*

*** 闭包的定义

闭包是“闭合”某个捕获变量的函数。也就是说，闭包不仅仅是一个函数，它还是一个能够“记住”创建它时的环境（包含变量）的函数。
环境，在这里是指函数在定义时能访问的变量和它们的值。
闭包的作用
函数与其环境绑定：在 Lisp 中，当一个函数返回时，如果该函数内部引用了一个外部变量，这个函数会与其引用的环境一起返回，也就是说，它不仅仅返回这个函数本身，还“记住”了当时的环境，这样这个函数仍然可以访问那些外部变量。这种函数称为闭包。

函数和变量之间的链接：闭包保留了对那些在定义时可访问的自由变量的引用，这意味着即使在闭包被调用时，这些变量可能已经在其他地方被修改或改变了作用域，闭包仍然“记得”它们原本的状态。

Lisp 中闭包的应用
返回其他函数：闭包的一种重要应用是将一个函数作为返回值传递出去。比如一个函数可以返回一个新的函数，而这个新的函数能够访问到原始函数定义时的局部变量状态，也就是闭包保留了那时的上下文环境。
实现私有变量：通过闭包，可以实现类似于面向对象编程中的私有变量。你可以创建只在闭包内部可访问的变量，从而避免了其他代码对这些变量的直接访问。
具体示例
可以通过一个示例更好地理解闭包：
#+begin_src elisp
(setq lexical-binding t)
(defun make-counter ()
  (let ((count 0))
    (lambda ()
      (setq count (+ count 1))
      count)))

(setq my-counter (make-counter))  ; my-counter 是一个闭包

(funcall my-counter)  ; 返回 1
(funcall my-counter)  ; 返回 2
(funcall my-counter)  ; 返回 3
在这个示例中：

(make-counter) 函数创建了一个闭包。
count 变量是在 make-counter 函数中定义的局部变量。
返回的 lambda 表达式（无名函数）就是闭包，它可以访问并修改 count。
每次调用 my-counter 时，count 都会加 1，并返回新的值，即使 count 在 make-counter 函数外部不可见，但在闭包内，它是可访问和可修改的。

#+end_src

总结
闭包在 Lisp 编程中是一种强大而灵活的特性，通过闭包，不仅能够返回函数，还能够通过保留上下文环境实现变量的封装和状态的持久化。

在 Emacs Lisp (Elisp) 中，闭包（Closures）指的是能够访问并操作其词法环境（lexical environment）中定义的变量的函数。
词法环境是指函数被定义时存在的变量绑定和值。当一个函数在一个特定的作用域内被定义，并且之后可以在外部环境中被调用时，
如果这个函数还能继续访问它被定义时所在作用域内的变量，那么这个函数就是一个闭包。

Elisp 默认使用动态作用域（dynamic scoping），这意味着函数内部变量的查找基于函数调用的位置而不是定义的位置。
然而，Elisp 也支持词法作用域（lexical scoping），这允许你创建闭包。
在 Elisp 中创建闭包通常需要使用 let 或者 cl-letf 结合 lambda 函数。let 创建一个新的词法环境，其中你可以定义局部变量，而 lambda 则创建一个匿名函数。
当这个匿名函数被返回或者以其他方式保存时，它会记住 let 块中变量的状态，即使 let 块已经执行完毕。

例如，下面是一个使用闭包的例子：
#+begin_src elisp
  (defun make-adder (n)
    (lambda (x)
      (+ n x)))

  (defvar add-five (make-adder 5))
  ;; `add-five` 现在是一个闭包，它记住了 `n` 的值是 5.
  (princ (funcall add-five 3)) ; 输出 8
  在这个例子中，make-adder 函数接收一个参数 n 并返回一个匿名函数（闭包）。
  这个匿名函数能够访问 n 的值，即使是在 make-adder 已经返回之后。当我们调用 add-five 时，它仍然可以访问到 n 的值，这是因为闭包保留了对原始词法环境的引用。
#+end_src

**** javaScript的例子
在JavaScript中，闭包（Closure）是一种特殊的作用域现象，它允许一个函数访问并操作其外部函数的变量，即使外部函数已经完成了执行。这是因为函数和其相关的变量环境被“封装”在一起，即使外部函数执行完毕，这个环境也不会被销毁，只要闭包函数还存在，这个环境就会一直保持。

闭包在JavaScript中非常重要，因为它提供了数据封装和私有变量的能力，同时也支撑了模块模式、事件监听器、异步编程、函数柯里化、防抖和节流等高级功能。

闭包的解释
当一个函数被定义在另一个函数内部时，这个内部函数就可以访问外部函数的局部变量和参数，即使外部函数已经返回。当内部函数被保存并稍后调用时，它依然可以访问这些变量，这就是闭包。

闭包的例子
下面是一个简单的闭包示例：
#+begin_src js
function outerFunction() {
    var outerVariable = "Hello, World!";

    function innerFunction() {
        console.log(outerVariable);
    }

    return innerFunction;
}

var myClosure = outerFunction();
myClosure();  // 输出 "Hello, World!"
#+end_src
在这个例子中，innerFunction 是一个闭包，因为它在 outerFunction 内部定义并且可以访问 outerVariable。当 outerFunction 被调用并返回 innerFunction 后，尽管 outerFunction 已经执行结束，但是 outerVariable 没有被销毁，因为 innerFunction 还在引用它。当 myClosure 被调用时，它依然可以访问并打印 outerVariable 的值。

注意事项
虽然闭包提供强大的功能，但也可能导致内存泄漏。如果闭包函数引用了大量的数据，并且长时间不被垃圾回收机制清理，这可能导致不必要的内存占用。因此，在使用闭包时，应当考虑其生命周期和是否有必要长期保留对外部变量的引用。

更复杂的例子
闭包也可以用来创建计数器：
#+begin_src js
function createCounter() {
    let count = 0;

    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.getCount()); // 输出 0
console.log(counter.increment()); // 输出 1
console.log(counter.decrement()); // 输出 0
#+end_src
在这个例子中，createCounter 返回一个对象，其中的方法可以访问并修改 count 变量，而 count 变量对全局作用域是不可见的，因此实现了封装和私有变量的效果。







*** 2.2.1 序列的表示

#+begin_src elisp
  (setq mylist (list 1 2 3 4))  ;; 创建一个列表并将其赋值给变量 `mylist`
  (car mylist)                  ;; 获取 `mylist` 的第一个元素
  (cdr mylist)                  ;; 获取2，3，4
  (car (cdr mylist))            ;; 获取 2
  (car (cdr (cdr mylist)))      ;; 获取3
#+end_src
